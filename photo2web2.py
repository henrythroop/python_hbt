#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun May 20 21:11:35 2018

@author: throop

PHOTO2WEB2.PY

This is the Python implementation of Photo2Web. The only thing it shares with the original Perl version is the name,
and the file structure. The main difference is that the slides are generated by the JS 'photogallery' tool,
rather than individual HTML pages.

The caption font size, alignment, etc. are defined in lightgallery.css. To edit them,
put their new values into .lg-sub-html and its descendents in photos.css .

I tried to use justifiedGallery to make the thumbnails slightly more beautiful. I probably could have gotten it
working eventually, but I didn't, and it's only a minimal improvement.

Henry Throop 22-May-2018

To be done:
    - Make a new thumnail generator. Thumbs now need to be made in the perl code.
      Consider using sips, which might be faster than imagemagick.
    - Make page responsive to different screen sizes.
    - Figure out why thumbnail animations are broken. [Can't figure it out. Abandoning.]
    - Add some CSS or something to make the header information < full screen width [DONE]
    - Reduce caption width to less than full screen width.
    - Make a new caption extractor. Use 'sips --getProperty description *jpg', which is much faster
      than exiftool.
    - Figure out what to do with YouTube links. [Ugh. I can embed them just fine, though ugly. But I can't 
      get them working the proper way.]
    - See if I can smallen the captions at all? Or put to side, or dismiss easily, or?? Since they always
      partially block.
    - Q: At one point I was getting a custom URL each time I clicked around. But no longer. Why not?? 
      I really prefer it. [SOLVED: Turn the 'hash' option back on.]

https://stackoverflow.com/questions/8631076/what-is-the-fastest-way-to-generate-image-thumbnails-in-python 

"""

import glob
import os.path
from html import escape
from bs4 import BeautifulSoup  # HTML parser
import subprocess

# =============================================================================
# Function definitions
# =============================================================================

def get_all_captions(files):
    """
    Given a list of files, returns a list of captions.
    This uses 'sips', which is far faster than exiftool.
    It does not depend on using a captions.txt file.
    """
    
    captions_all = subprocess.check_output(['sips', '--getProperty', 'description'] + files).decode("utf-8")
    
    captions = []
    for i in range(len(files)):
        if (i < len(files)-1):
            pos1 = captions_all.find(files[i])
            pos2 = captions_all.find(files[i+1])
            caption_i = captions_all[pos1:pos2]
        else:
            pos1 = captions_all.find(files[i])
            caption_i = captions_all[pos1:]
        caption_i = caption_i.replace(files[i], '')
        caption_i = caption_i[16:]
        caption_i = caption_i[:-1]  # Remove final \n
        caption_i = caption_i.replace('<nil>', '')  # Remove <nil>
        captions.append(caption_i)
#        print(f'Added caption {caption_i}')
        
    return captions
        
def make_gallery_item(caption, basename, type = 'span'):
    """
    Return an HTML line for the gallery.
    
    Parameters
    -----
    
    caption:
        String caption, HTML.
        
    basename:
        String. Can be a filename (IMG_5534.jpg) or a URL (http://www.youtube.com/asdfk98)
        
    """
    
    if '.jpg' in basename:
        line  = f'<span class="item" data-sub-html="<span class=caption>{caption}</span>"' + \
                f' data-src="originals/{basename}">\n' + \
                f'  <a href="originals/{basename}">\n' + \
                f'  <img src="thumbnails/s{basename}"/>\n' + \
                f'  </a>\n' + \
                f'  </span>\n\n'

    if 'youtu' in basename:
        id = basename.split('/')[-1]  # Get the video ID (e.g., wiIoy44Q4)
        line  = f'<span class="item"' + \
                f' data-src="{basename}"> ' + \
                f'  <a href="{basename}" data-src="{basename}"> ' + \
                f'  <img src="http://img.youtube.com/vi/{id}/default.jpg"/>' + \
                f'  </a>' + \
                f'  </span>\n\n'

# For debugging, 
# http://throop/photos/Trips/Test/show.html#lg=1&slide=89
# Solved! Looks like link must be of form https://youtu.be/AuCqrwxquPU .  And, the base browser URL for gallery
                # itself must be http://, not file:// or else get JS errors.
# Problem: how long does it take PowWeb to update my directory??  It's some finite time, like 10 minutes.              
                
        # As a test, define the element as an <a> anchor.
        
#    line_a = f'<span class="item"> <a href="originals/{basename}"> <img src="thumbnails/s{basename}"/> </a></span>\n\n'

    return line

# =============================================================================
# Start main code
# =============================================================================

def photo2web():

    dir_photos = '/Users/throop/photos/Trips/Bhutan_Mar18'
    
    files_original = glob.glob(os.path.join(dir_photos, 'originals/*.jpg'))

    # Here, define a <span> </span> element which is the image itself. 
    # We tag this span with class=item, and then use a corresponding selector in the call to lightgallery.
    # This prevents lightgallery from being called on headers, <hr>, and random text on the page which is not pics.
    
    dir_js = '/Users/throop/photos/Trips/js'
    dir_lg = os.path.join(dir_js, 'lightGallery-master')
    
    file_captions  = os.path.join(dir_photos, 'captions.txt')   # List of all captions, one per line-pair, via exiftool
    file_header    = os.path.join(dir_js, 'header.html')    # Header with JS includes, CSS, etc.   
    file_footer    = os.path.join(dir_js, 'footer.html')  # HTML footer with JS startup, etc.
    file_header_txt= os.path.join(dir_photos, 'header.txt')  # Header file which I type manually. Line0 is gallery title
    file_out       = os.path.join(dir_photos, 'index.html')    # Final output filename
    
    captions = []
    header   = []
    footer   = []
    
    header_txt = []
    
    captions = get_all_captions(files_original)
    
    print('Read {len(captions)} captions')
    
    # Read text header
            
    with open(file_header_txt, "r") as lun:
        for line in lun:
            header_txt.append(line)
    
    # Extract the title of the gallery from the header.txt file
            
    title_gallery = header_txt[0]
    header_txt = header_txt[1:]
    
    # Read HTML header. Plug in the gallery name as needed.
              
    with open(file_header, "r") as lun:
        for line in lun:
            header.append(line.replace('TITLE_HERE', title_gallery))
    
    # Read HTML footer
            
    with open(file_footer, "r") as lun:
        for line in lun:
            footer.append(line)
    
    # Now do the output
            
    lun = open(file_out, "w")
    
    # Write HTML header
    
    for line in header:
        lun.write(line)
    
    # Write text header
    
    for line in header_txt:
        lun.write(line)
    
    lun.write('<div class="demo-gallery">\n')
    lun.write('<div id="lightgallery" class="list-unstyled row">' + "\n")
    
    j = 0
    # Loop and print the entry for each image
    
    for i,file in enumerate(files_original):
    
        caption = captions[i]
    
        # If this image starts a new section, then create the HTML for that
    
        if  '##' in captions[i]:
            if (j > 0):
                lun.write('</div>\n')
            caption, section = caption.split('##')
            lun.write(f'<br><hr> <h3>{section}</h3>\n\n')
            lun.write(f'<div id="gallery{j}">\n')
            j+=1
    
        # If caption is just a filename, then zero it out
        
        if '.jpg' in caption:
            caption = ''
            
        # Handle " < > etc in captions. But actually I'm not sure I want to do that... just quotes, perhaps.
        
        caption = caption.replace('"', '&quot;')
        caption = caption.replace("'", '&#x27;')
        
        basename = os.path.basename(file)

        # If the caption has a youtube link in it, make a new slide for that.
        # Convention is this: If there is a youtube movie, put its URL in the 
        # Lightroom caption for the *previous* image. Write it like this:
        #  "And here we are swimming.<a href=httpw://youtu.be/mov12498jE>Swimming movie!</a>"
        # Don't put in the <embed> or anything like that.
        
        if ('youtube.com' not in caption) and ('youtu.be' not in caption):
            line = make_gallery_item(caption, basename)                     # Normal caption and URL

        else:    
            matchstr        = '<a href=https://you'
            
            (caption1, html) = caption.split(matchstr)
            line1           = make_gallery_item(caption1, basename)
            html             = matchstr + html
            soup            = BeautifulSoup(html, 'html5lib')
            a               = soup.find_all('a')[0]
            url             = a.get('href')
            caption2        = a.contents[0]
            line2           = make_gallery_item(caption2, url)            
            line            = line1 + line2
        
        # Print the entire HTML line, with image, thumbnail, and caption, to the file
    
        lun.write(line)
        print(line) 
       
   # Print the HTML footer, and close the file
    
    lun.write('</div>\n')    
    lun.write('</div>\n')
        
    for line in footer:
        lun.write(line)    
        
    lun.close()
    print(f'Wrote: {file_out}')

# =============================================================================
# Call the main code
# =============================================================================

if (__name__ == '__main__'):
    photo2web()
    