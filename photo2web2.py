#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun May 20 21:11:35 2018

@author: throop

PHOTO2WEB2.PY

This is the Python implementation of Photo2Web. The only thing it shares with the original Perl version is the name,
and the file structure. The main difference is that the slides are generated by the JS 'photogallery' tool,
rather than individual HTML pages.

The caption font size, alignment, etc. are defined in lightgallery.css. To edit them,
put their new values into .lg-sub-html and its descendents in photos.css .

I tried to use justifiedGallery to make the thumbnails slightly more beautiful. I probably could have gotten it
working eventually, but I didn't, and it's only a minimal improvement.

Henry Throop 22-May-2018

To be done:
    - Make a new thumnail generator. Thumbs now need to be made in the perl code.
      Consider using sips, which might be faster than imagemagick.
    - Make page responsive to different screen sizes.
    - Figure out why thumbnail animations are broken. [Can't figure it out. Abandoning.]
    - Add some CSS or something to make the header information < full screen width [DONE]
    - Reduce caption width to less than full screen width.
    - Make a new caption extractor. Use 'sips --getProperty description *jpg', which is much faster
      than exiftool. [DONE]
    - Figure out what to do with YouTube links. [Ugh. I can embed them just fine, though ugly. But I can't 
      get them working the proper way.] [FIXED]
    - See if I can smallen the captions at all? Or put to side, or dismiss easily, or?? Since they always
      partially block.
    - Q: At one point I was getting a custom URL each time I clicked around. But no longer. Why not?? 
      I really prefer it. [SOLVED: Turn the 'hash' option back on.]

# 29-May-2018
      
      - Thumbnails are not yet made by this program. So, to use:
          - Output all files from LR
          - run 'photo2web_old' (perl). This will copy files into originals/, make the thumbnails, and extract captions,
                       and put into show_old.html and index_old.html.
          - run 'phtoto2web' (python, this program). This will make the HTML, fancy JS gallery, etc. and put into 
                       index.html .
                       
# 17-Sep-2018
      - Handling of movies improved. Now there is a YOUTUBE: tag supplied, rather than a link; this can be parsed
        by both old and new galleries more consistently.
        
# 9-Jan-2021
      - Makes two output files now: one with a thumbnail view of all images (like before), and one with a 
        blog-style view (new -- though actually like the original photo2web). Both versions are JS-based and 
        use LightGallery.
        
        This development *retires* the original output form the original photo2web page. I will still keep that
        code, because it makes the thumbnails. But the HTML it generates is really not used any more.
        
Bug: for some reason the HTML outputted is not good for galleries with no captions at all. Not sure why. 
I think it is a vestiage of the original photo2web, and having to force run 'captions_photo2web'
        
Bug: If there are no sections, then the 'Jump to section' text should not be printed.
                       
"""

import glob
import os.path
import os
from html import escape
from bs4 import BeautifulSoup  # HTML parser
import subprocess
import datetime
from shutil import copyfile

# =============================================================================
# Function definitions
# =============================================================================

def get_all_captions(files):
    """
    Given a list of files, returns a list of captions.
    This uses 'sips', which is far faster than exiftool.
    It does not depend on using a captions.txt file.
    
    NB: I used to use .decode('utf-8'). But this caused some error, and using ISO-8859-1 seems to fix that.
    
    NB: Looks like sips --getProperty description has a bug. If the length is > 1024 characters, then it returns 
    junk. No warning, and no way to detect this, except by seeing junk in the output.
    
    If captions are turned into junk, they just have to be shortened in Lightroom.
    
    """
    
    captions_all = subprocess.check_output(['sips', '--getProperty', 'description'] + files).decode("ISO-8859-1")
     
    captions = []
    for i in range(len(files)):
        if (i < len(files)-1):
            pos1 = captions_all.find(files[i])
            pos2 = captions_all.find(files[i+1])
            caption_i = captions_all[pos1:pos2]
        else:
            pos1 = captions_all.find(files[i])
            caption_i = captions_all[pos1:]
        caption_i = caption_i.replace(files[i], '')
        caption_i = caption_i[16:]
        caption_i = caption_i[:-1]  # Remove final \n
        caption_i = caption_i.replace('<nil>', '')  # Remove <nil>
        captions.append(caption_i)
        # print(f'Added caption {i}: {caption_i}')
        
    return captions

def get_all_captions_old(files):
    """
    Read in captions from the captions.txt file. Don't usually use this.
    """

    captions = []
    lun = open("captions.txt", "r")
    captions = lun.readlines()
    lun.close()
    captions_fixed = captions[0:-1:2]  # Alternate lines are blank
    captions_fixed.append(captions[-1])
    for i in range(len(captions_fixed)):
        captions_fixed[i] = captions_fixed[i].rstrip()
        print(f'{i}. {captions_fixed[i]} using OLD')
    
    return captions_fixed

def make_gallery_thumbs_item(caption, basename, type = 'span'):
    """
    Return an HTML line for the gallery.
    Each caption is wrapped in <span class=lg-caption>, and LightGallery further wraps this in <div lg-sub-html>.

    Parameters
    -----
    
    caption:
        String caption, HTML.
        
    basename:
        String. Can be a filename (IMG_5534.jpg) or a URL (http://www.youtube.com/asdfk98)
        
    """
    
    if '.jpg' in basename:
        line  = f'<span class="item" data-sub-html="<span class=lg-caption>{caption}</span>"' + \
                f' data-src="originals/{basename}">\n' + \
                f'  <a href="originals/{basename}"><img src="thumbnails/s{basename}"/></a>\n' + \
                f'  </span>\n\n'

    if 'youtu' in basename:
        id = basename.split('/')[-1]  # Get the video ID (e.g., wiIoy44Q4). # Create the YouTube thumbnail!
        id = id.replace('watch?v=', '')
        line  = f'<span class="item"' + \
                f' data-src="{basename}"> ' + \
                f'  <a href="{basename}" data-src="{basename}">' + \
                f'  <img src="http://img.youtube.com/vi/{id}/hqdefault.jpg"/></a>' + \
                f'  </span>\n\n'

        # As a test, define the element as an <a> anchor.
        
#    line_a = f'<span class="item"> <a href="originals/{basename}"> <img src="thumbnails/s{basename}"/> </a></span>\n\n'

    return line

def make_gallery_blog_item(caption, basename, type = 'span'):
    """
    Return an HTML line for the gallery, blog-style.
    Each caption is wrapped in <span class=lg-caption>, and LightGallery further wraps this in <div lg-sub-html>.

    Parameters
    -----
    
    caption:
        String caption, HTML.
        
    basename:
        String. Can be a filename (IMG_5534.jpg) or a URL (http://www.youtube.com/asdfk98)
        
    """
    
    if '.jpg' in basename:
        line  = '<table align=middle cellspacing=50 id=photoCellHorizontal>' + \
                f'<tr><td align=middle>' + \
                f'<span class="item" data-sub-html="<span class=lg-caption>{caption}</span>"' + \
                f' data-src="originals/{basename}">\n' + \
                f'  <a href="originals/{basename}"><img src="thumbnails/i{basename}"/></a>\n' + \
                f'  </span>' + \
                f'</td>' + \
                f'<td cellpadding=10 width=0.3>' + \
                f'<div class=caption><p>' + \
                f'{caption}' + \
                f'</p></div>' + \
                f'</td></tr>' + \
                f'</table>'    

    if 'youtu' in basename:
        id = basename.split('/')[-1]  # Get the video ID (e.g., wiIoy44Q4). # Create the YouTube thumbnail!
                                      # Can use 'maxresdefault' or 'hqdefault' or 'default' 
        id = id.replace('watch?v=', '')
        
        line  = '<table align=middle cellspacing=50 id=photoCellHorizontal>' + \
                f'<tr><td align=middle>' + \
                f'<span class="item" data-sub-html="<span class=lg-caption>{caption}</span>"' + \
                f' data-src="originals/{basename}">\n' + \
                f'  <a href="http://youtu.be/{id}">' + \
                f'   <img src="http://img.youtube.com/vi/{id}/hqdefault.jpg"/></a>\n' + \
                f'  </span>' + \
                f'</td>' + \
                f'<td cellpadding=10 width=0.3>' + \
                f'<div class=caption>' + \
                f'<iframe width="560" height="315" src="https://www.youtube.com/embed/RT2tViflM_A" frameborder="0"' + \
                f' allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"' + \
                f' allowfullscreen></iframe>' + \
                f'</td></tr>' + \
                f'</table>'    
        
        
        
        
        # line  = f'<span class="item"' + \
                # f' data-src="{basename}"> ' + \
                # f'  <a href="{basename}" data-src="{basename}">' + \
                # f'  <img src="http://img.youtube.com/vi/{id}/hqdefault.jpg"/></a>' + \
                # f'  <div class=caption><a href=http://youtu.be/{id}></div>' + \
                # f'  </span>\n\n'

        # As a test, define the element as an <a> anchor.
        
#    line_a = f'<span class="item"> <a href="originals/{basename}"> <img src="thumbnails/s{basename}"/> </a></span>\n\n'

    return line

def make_thumbnails(files):
    """
    Make thumbnails for the specified files.
    """
    
    # OK, right now this code does nothing. I want it to do the same as the original Perl code did:
    
#    o Get a list of new .jpg's in the main directory
#    o For each one:
#        o If basename of it matches one in originals, make new thumbs and copy and replace
#        o If it doens't match an existing one, then (?? -- not sure) -- make new thumbs and copy, no rename
#       
    
    return None

def check_path_ok():
    """
    Make sure we are running in an OK directory
    """

    file_inhibit = '.photo2web_inhibit'

    if os.path.isfile(file_inhibit):
      exit(f'File {file_inhibit} found -- stopping!');

def output(lun_list, s):
    """
    Output a line of text or to a series of lun's. No explicit error handline.
    Used to write HTML to one or more files.
    
    Parameters
    ----------
    luns : list of luns, or a single lun
        List of lun's to write to
    s: string
        String to write to each of these luns

    Returns
    -------
    None.

    """
    
    # print(f'{s}')
    
    for lun in lun_list:
        # print (f'outputting... {s}')
        lun.write(s)
    # else:
    #     print (f'outputting single... {s}')
    #     print(f'lun={luns}')
    #     luns.write(s)

# =============================================================================
# Start main code
# =============================================================================

def photo2web():

    # os.chdir('/Users/throop/photos/Trips/ConjunctionJupiterSaturn_Dec20')
    
    check_path_ok()

    dir_photos = os.getcwd()
    
    files_original = sorted(glob.glob(os.path.join(dir_photos, 'originals/*.jpg')))

    # Here, define a <span> </span> element which is the image itself. 
    # We tag this span with class=item, and then use a corresponding selector in the call to lightgallery.
    # This prevents lightgallery from being called on headers, <hr>, and random text on the page which is not pics.
    
    dir_js = '/Users/throop/photos/Trips/js'
    dir_lg = os.path.join(dir_js, 'lightGallery-master')
    
    file_captions  = os.path.join(dir_photos, 'captions.txt')   # List of all captions, one per line-pair, via exiftool
    file_header    = os.path.join(dir_js, 'header.html')    # Header with JS includes, CSS, etc.   
    file_footer    = os.path.join(dir_js, 'footer.html')  # HTML footer with JS startup, etc.
    file_header_txt= os.path.join(dir_photos, 'header.txt')  # Header file which I type manually. Line0 is gallery title
    file_out_thumbs = os.path.join(dir_photos, 'index_m.html')    # Final output filename, for the thumb-based one
    file_out_blog   = os.path.join(dir_photos, 'index.html')    # Final output filename, for the blog-like one
    
    captions = []
    header   = []
    footer   = []
    
    header_txt = []
    
    # Get captions from the EXIF info
    # If the flag is set, then read from captions.txt file, instead of from EXIF headers. This is usually just 
    # if I'm reprocessing an old gallery.
    
    DO_CAPTIONS_TXT = False
    
    if DO_CAPTIONS_TXT:
        captions = get_all_captions_old(files_original)
        print('Warning: Reading from captions.txt file, not from EXIF info. See flag DO_CAPTIONS_TXT')
    else:
        captions = get_all_captions(files_original)
    
    print(f'Read {len(captions)} captions')
    
    DO_PRINT_CAPTIONS = False
    
    if DO_PRINT_CAPTIONS:
        for caption in captions:
            print(caption)
    
    # Read text header
            
    with open(file_header_txt, "r") as lun:
        for line in lun:
            header_txt.append(line)
    
    # Extract the title of the gallery from the header.txt file
            
    title_gallery = header_txt[0]
    header_txt = header_txt[1:]
        
    # Wrap the 'text header' in a <div>
    # 'Text header' is the narrative introduction to the file ('I went on a trip...')
    # Apply any CSS here -- e.g., to shrinks the margins a bit, to make it easier to read.
    
    header_txt = ["<div class=header>"] + header_txt + ["</div>"]
    
    # Read 'HTML header'. Plug in the gallery name as needed.
    # 'HTML header' is the page title, the CSS and JS inclusions, etc.
    # The '?s=1' switch forces target page not to be reloaded.
     
    with open(file_header, "r") as lun:
        for line in lun:
            header.append(line.replace('TITLE_HERE', title_gallery))

    header_blog = header.copy()
    header_thumbs = header.copy()
    
    header_blog.append('<div>DESKTOP &starf;</div><div><a href=index_m.html?s=1>MOBILE</a></div>')
    header_thumbs.append('<div><a href=index.html?s=1>DESKTOP</a></div><div>MOBILE &starf;</div>')
    
    header_thumbs.append("<p><a href='..'>Back to galleries</a><p>\n")
    header_blog.append("<p><a href='..'>Back to galleries</a><p>\n")

    # Read HTML footer. Plug in the date as needed.
            
    datestr = datetime.datetime.now().strftime("%d %b %Y")
    with open(file_footer, "r") as lun:
        for line in lun:
            footer.append(line.replace('DATE_HERE', datestr))
    
    # Now create the output files themselves.
            
    lun_blog   = open(file_out_blog, "w")    # File that has the blog-style entries
    lun_thumbs = open(file_out_thumbs, "w")  # File that has the thumbnails only 
    
    # Make a list of all the LUN's that we output to. This way, we can easily write to two files with just one call.
    
    luns = [lun_blog, lun_thumbs]
    
    # Write 'HTML header' to the file
    
    for line in header_blog:
        output([lun_blog], line)

    for line in header_thumbs:
        output([lun_thumbs], line)
    
    # Write 'text header' to the file
    
    for line in header_txt:
        output(luns, line)
    
    output(luns,'<div class="demo-gallery">\n')
    output(luns,'<div id="lightgallery" class="list-unstyled row">' + "\n")
    
    j = 0
    
    ## Make a list of sections here.
    
    output(luns, '<FONT SIZE=+0></B><br>Jump to section:<br></FONT></B>\n')
    output(luns, '<ul>')
    
    for i,file in enumerate(files_original):
    
        caption = captions[i]
    
        # If this image starts a new section, then create the HTML for that
    
        if  '##' in captions[i]:
            caption, section = caption.split('##')
            output(luns,f'<li class=section><a href=#{j+1}>{section}</a><br>\n')
            # print(f'Section = {section}<br>')
            j+=1
                                             
    output(luns,'</ul>')
            
    # Loop and print the entry for each image
    
    j = 0
    
    for i,file in enumerate(files_original):
    
        caption = captions[i]
    
        # If this image starts a new section, then create the HTML for that
    
        if  '##' in captions[i]:
            if (j > 0):
                output(luns, '</div>\n')
            caption, section = caption.split('##')
            output(luns, f'<br><hr> <a name={j+1}></a> <h3>{section}</h3>\n\n')  # Anchor tag, so we can use index.html#1
            output(luns, f'<div id="gallery{j}">\n')
            j+=1
    
        # If caption is just a filename, then zero it out
        
        if '.jpg' in caption:
            caption = ''
            
        # Handle " < > etc in captions. But actually I'm not sure I want to do that... just quotes, perhaps.
        
        caption = caption.replace('"', '&quot;')
        caption = caption.replace("'", '&#x27;')
        
        basename = os.path.basename(file)

        # If the caption has a youtube link in it, make a new slide for that.
        # Convention is to write it like this. Do not wrap any HTML or caption around it!
        #
        #         This is a caption. YOUTUBE:mov1249
        #
        # This will be automatically converted to the right link for either the old HTML gallery,
        # or the new JS gallery. 
        #  - In the new JS gallery, one slide will become two.
        #  - In the old HTML gallery, the YOUTUBE link will be turned into an <embed> link.
        
        if ('YOUTUBE:' not in caption):
            line_thumbs = make_gallery_thumbs_item(caption, basename)                     # Normal caption and URL
            line_blog   = make_gallery_blog_item(caption, basename)
            
        else:    
            
            try:
                (caption1, video) = caption.split('YOUTUBE:')
            except:
                raise ValueError(f"Can't parse caption: {caption}")

            line1_blog        = make_gallery_blog_item(caption1, basename)
            line1_thumbs      = make_gallery_thumbs_item(caption1, basename)

            url               = f'https://www.youtube.com/watch?v={video}'
            html              = f'<a href={url}>Link</a>'
            line2_blog        = make_gallery_blog_item(caption1, url)
            line2_thumbs      = make_gallery_thumbs_item(caption1, url)
            
            line_thumbs       = line1_thumbs + line2_thumbs
            line_blog         = line1_blog + line2_blog
        
            # XXX Not sure this line is right -- 10-Jan-2021
            
            # line_thumbs = line
            # line_blog = line
            
            # caption2        = a.contents[0]
            # html             = matchstr + html
            # soup            = BeautifulSoup(html, 'html5lib')
            # a               = soup.find_all('a')[0]
            # line1           = make_gallery_item(caption1, basename)
            # html             = matchstr + html
            # soup            = BeautifulSoup(html, 'html5lib')
            # a               = soup.find_all('a')[0]
            # url             = a.get('href')
            # caption2        = a.contents[0]
            # line2           = make_gallery_item(caption2, url)            
            # line            = line1 + line2
        
        # Print the entire HTML line, with image, thumbnail, and caption, to the file

        # This line here is DIFFERENT for the BLOG vs. THUMBS output files.
        
        output([lun_thumbs], line_thumbs)
        output([lun_blog],   line_blog)
       
   # Print the HTML footer, and close the file
    
    output(luns, '</div>\n')    
    output(luns, '</div>\n')
        
    for line in footer:
        output(luns, line)    
        
    for lun in luns:
        lun.close()
    print(f'Wrote: {file_out_blog}')
    print(f'Wrote: {file_out_thumbs}')
    
    # Finally, copy the landing page
    # 
    # copyfile(dir_js + '/index_landing.html', dir_photos + '/index.html')
    

# =============================================================================
# Call the main code
# =============================================================================

if (__name__ == '__main__'):
    photo2web()
    
