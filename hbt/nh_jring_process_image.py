#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Fri Sep  2 12:34:07 2016

@author: throop
"""

import pdb
import glob
import math       # We use this to get pi. Documentation says math is 'always available' 
                  # but apparently it still must be imported.

import os.path

import astropy
from   astropy.io import fits
from   astropy.table import Table
import astropy.table   # I need the unique() function here. Why is in in table and not Table??
import astropy.visualization
import matplotlib.pyplot as plt # pyplot
import numpy as np
import astropy.modeling
from matplotlib import cm

import pickle # For load/save

import hbt

##########
# Process Image -- do all of the processing on the current image
##########
         
# Returns an image with stray light model removed.
# Stray light removal is two steps:
#   1. Remove high frequency, which is using a model generated by summing other images
#   2. Remove low frequency, by fitting a polynomial.
#
# The image returned is a science image, with flux (ie, I/F) preserved.
# No clipping or scaling has been done.

def nh_jring_process_image(image_raw, method, vars, index_group, index_image):
    """Return image with stray light removed. I/F is preserved and no clipping is done."""
    
# Load the arrays with all of the filenames

    file_pickle = '/Users/throop/Data/NH_Jring/out/nh_jring_read_params_571.pkl' # Filename to get filenames, etc.
    
    lun = open(file_pickle, 'rb')
    t = pickle.load(lun)
    lun.close()

    # Process the group names. Some of this is duplicated logic -- depends on how we want to use it.

    groups = astropy.table.unique(t, keys=(['Desc']))['Desc']
    
#    groupname = 'Jupiter ring - search for embedded moons'
#    groupnum = np.where(groupname == groups)[0][0]
        
    groupmask = (t['Desc'] == groups[index_group])
    t_group = t[groupmask]	

    frac, poly = 0, 0
    
    if (method == 'Previous'):
        file_prev = t_group['Filename'][index_image-1]
#            print "file =      " + filename
        print("file_prev = " + file_prev)
        image_bg = hbt.read_lorri(file_prev, frac_clip = 1.0, bg_method = 'None', autozoom=True)
        image_fg = image_raw
        image = image_fg - image_bg
        image_processed = image

    if (method == 'Next'):
        file_next = t_group['Filename'][index_image+1]
        image_bg = hbt.read_lorri(file_next, frac_clip = 1.0, bg_method = 'None', autozoom=True)
        image_fg = image_raw
        image = image_fg - image_bg
        image_processed = image
        
    if (method == 'Median'): # XXX not working yet
        file_prev = t_group['Filename'][index_image-1]
        image_bg = hbt.read_lorri(file_prev, frac_clip = 1.0, bg_method = 'None')
        image_fg = image_raw
        image = image_fg - image_bg
        image_processed = image

    if (method == 'Polynomial'):
        
        power = vars
        image = image_raw - hbt.sfit(image_raw, power) # Look up the exponenent and apply it
        image_processed = image
                                            
    if (method == 'Grp Num Frac Pow'):  # Specify to subtract a specified group#/image#, mult factor, and sfit power.
                                        # I thought this would be useful, but it turns out we usually need to subtract
                                        # a median of multiple images -- not just one -- so this is not very useful.
                                        # Plus, the best power is usually 5, and the best frac can be calc'd
                                        # with a linfit.
            
        if (np.size(vars) == 0): # If no args passed, just plot the image
            power = 0
            frac  = 0
            image = image_raw

        if (np.size(vars) == 1): # One variable: interpret as exponent
            power = float(vars[0])
            frac  = 0
            image = image_raw
            image_bg = hbt.sfit(image, power)
            image = image - image_bg
            
        if (np.size(vars) == 2): # Two variables: interpret as group num and file num
            (grp, num) = vars
            frac  = 1
            power = 0
            
        if (np.size(vars)) == 3: # Three variables: interpret as group num, file num, fraction
            (grp, num, frac) = vars
            power = 0
            
        if (np.size(vars) == 4): # Four variables: Group num, File num, Fraction, Exponent
            (grp, num, frac, power) = vars
             
        if int(np.size(vars)) in [2,3,4]:
           
            grp = int(grp)
            num = int(num)
            frac = float(frac)
            power = int(power)
            
            print("group={}, num={}, frac={}".format(grp, num, frac))
#            print "Group = {}, num{}, Name = {}".format(name_group, num, name)

            name_group = groups[grp]
            groupmask = t['Desc'] == name_group
            group_tmp = t[groupmask]
            filename_bg = group_tmp['Filename'][num]
                                    
            image_fg = image_raw
            image_bg = hbt.read_lorri(filename_bg, frac_clip = 1, bg_method = 'None')
            
            image = image_fg - float(frac) * image_bg                
            image = image - hbt.sfit(image, power)
            
        image_processed = image
    
    if (method == 'String'):

# Parse a string like "6/112-6/129", or "129", or "6/114", or "124-129" or "6/123 - 129"
# As of 8-July-2016, this is the one I will generally use for most purposes.
# 'String' does this:
#   o Subtract the bg image made by combining the named frames
#   o Subtract a 5th order polynomial
#   o Filter out the extreme highs and lows
#   o Display it.    

        str = vars
        str2 = str.replace('-', ' ').replace('/', ' ')

        vars = np.array(str2.split(), dtype=int)  # With no arguments, split() breaks at any set of >0 whitespace chars.
        
        if (np.size(vars) == 0):
            image = image_raw
            image_processed = image
            return
            
        if (np.size(vars) == 1):
            image_stray = hbt.nh_get_straylight_median(index_group, [int(vars[0])])  # "122" -- assume current group
            
        if (np.size(vars) == 2):
            image_stray = hbt.nh_get_straylight_median(index_group, 
                                                      hbt.frange(int(vars[0]), int(vars[1])).astype('int'))  # "122-129"
                                                                                        # -- assume current group
 
        if (np.size(vars) == 3):
            print("vars = ")
            print(vars)
            image_stray = hbt.nh_get_straylight_median(int(vars[0]), 
                                                      hbt.frange(vars[1], vars[2]).astype('int')) # "5/122 - 129"
            
        if (np.size(vars) == 4):
            image_stray = hbt.nh_get_straylight_median(int(vars[0]), 
                                                      hbt.frange(vars[1], vars[3]).astype('int')) # "6/122 - 6/129"

# Subtract stray light from original, and then remove an sfit(5) from that

        image_processed = image_raw - image_stray    
        
        image_processed = hbt.remove_sfit(image_processed,5)
                        
    if (method == 'None'):
        
        image_processed = image = image_raw

# Remove a small bias offset between odd and even rows. 
# This might be better done before the sfit(), but in reality probably doesn't make a difference.

    image_processed = hbt.lorri_destripe(image_processed)
    
# If requested: plot the image, and the background that I remove. 
# Plot to Python console, not the GUI.

# Test stretching here
# We use astropy's stretching here, rather than matplotlib's norm= keyword. The basic idea of both of these 
# is the same, but I know that astropy has a percentile stretch available.

    DO_DIAGNOSTIC = False
    
    if (DO_DIAGNOSTIC):

        stretch = astropy.visualization.PercentileInterval(90)  # PI(90) scales array to 5th .. 95th %ile

        plt.rcParams['figure.figsize'] = 16,6

# Column 1: raw image

        im = image_raw

#        plt.subplot(3,3,1) # vertical, horizontal, index = typewriter-style
#        plt.title('image_raw, mean=' + hbt.trunc(np.mean(im),3))
#        plt.imshow(stretch(im))
#        
#        plt.subplot(3,3,4) # vertical, horizontal
#        plt.imshow(stretch(im))
#        plt.title('image_raw, mean=' + hbt.trunc(np.mean(im),3))

        im = hbt.remove_sfit(im,5)
        plt.subplot(1,3,1) # vertical, horizontal, index
        plt.imshow(stretch(hbt.remove_sfit(im,5)))
        plt.title('image_raw - sfit(imag_raw,5), mean=' + hbt.trunc(np.mean(im),3))
        
#       Column 2: Stray only. This will throw an error if we haven't read in a stray light file -- just ignore it.

#        im = stray
 
#        plt.subplot(3,3,2)
#        plt.imshow(stretch(im))
#        plt.title('stray_norm, mean=' + hbt.trunc(np.mean(im),3))
#
#        plt.subplot(3,3,5)
#        plt.imshow(stretch(im))
#        plt.title('stray_norm, mean=' + hbt.trunc(np.mean(im),3))
        
        plt.subplot(1,3,2)
        try:
            plt.imshow(stretch(hbt.remove_sfit(image_stray,5))) # This won't do much since it is already applied
        except UnboundLocalError:
            print("No stray light to subtract")
        
        plt.title('stray_norm - sfit(stray_norm,5), mean=' + hbt.trunc(np.mean(im),3))

        # Column 3: raw - stray
        
#        im = image_raw - stray_
        
#        plt.subplot(3,3,3)
#        plt.imshow(stretch(im))
#        plt.title('raw - stray, mean=' + hbt.trunc(np.mean(im),3))
#
#        im = hbt.remove_sfit(im,5) - stray_norm
#        
#        plt.subplot(3,3,6)
#        plt.imshow(stretch(im))
#        plt.title('raw-s5(raw) - stray, mean=' + hbt.trunc(np.mean(im),3))

        plt.subplot(1,3,3)

        try:
            im = hbt.remove_sfit(image_raw - image_stray,5)
            plt.imshow(stretch(im))
        except UnboundLocalError:  
            print("No stray light to subtract")
        
        plt.title('sfit(raw-stray,5), med ' + hbt.trunc(np.median(im),3))
        
        plt.show()

    return image_processed